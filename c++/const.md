# const
`const`的用法非常灵活,能够大大增强程序的健壮性.
1. 定义常量
    ```cpp
    const int c = 0;
    ```
2. 保护变量不被更改
    ```cpp
    void f(const int i) { i=10;//error! }
        //如果在函数体内修改了i，编译器就会报错
    ```
    上述代码传递的是副本,更改影响并不大,`const`往往和引用一起使用,节省空间并增强健壮性
    ```cpp
    void f(const int &i){...}
    ```
    i 的值为引用,并且不允许被更改.
    也可以对返回值为引用的变量加上这个修饰,这样这个引用就不能被更改
    ```cpp
    const string& get_name() const 
    { 
        return name; 
    } 
    ```
3. 全局调整参数,类似宏定义
4. 类型安全检查
    ```cpp
    void f(const int i) { .........}
        //对传入的参数进行类型检查，不匹配进行提示
    ```
    宏定义仅仅对宏进行替换,没有类型检查,往往会导致意想不到的错误.
5. 修饰成员函数
    被`const`修饰的成员函数,不能改变这个类对象的值(指针访问可以,但是并不推荐)
    - `const`对象只能访问`const`成员函数,一般对象则都可以(包括`const`和其他共有函数)

6. 节省空间
    当定义`const`的时候,仅仅给出了常量的内存地址,并没有分配内存.
    在程序执行过程中,仅仅进行一次内存的分配,即使这个值被引用多次.

7. `const`成员和应用成员只能使用初始化列表来进行构造函数.

8. `const`的变量必须初始化,分为常变量和常指针.
    ```cpp
    int a = 10;
    const int *p;
    p = &a;
    *p = 3; // 错误，通过此指针改变指向的值
    int b = 5;
    p = &b; // 正确
    int c = 10;
    int * const p = &c;
    *p = 5; // 正确
    int d = 5;
    p = &d; // 错误，指针变量不能改变
    ```
    (1) int *p  -- p是个非const指针，指向的对象是int；
    (2) const int *p  --  p是个非const指针，指向的对象是const int；
    (3) int * const p  -- p是个const指针，指向的对象是int；
    (4) const int * const p  -- p是个const指针，指向的对象是const int。
    以上四个都是定义指针p，如果初始化是指初始化指针p，而不是它所指向的对象，由于(3)和(4)中指针p是const的，所以必须初始化。(1)和(2)中的指针p是非const的，可以不初始化。
9. const 和宏
    - const 有数据类型, 宏没有
    - const 会进行安全检查, 后者只进行字符替换,容易发生意想不到的错误
    - #define 发生在编译之前,不做语法检查