# new malloc 区别
1. 申请内存所在的位置不同
`new`在自由储存区分配内存空间,`malloc`从堆上动态分配内存.

2. 返回类型不同
`new`在分配内存成功的时候,返回对象类型的指针,类型安全
`malloc`返回`void*`,需要强制转换

3. 分配失败时的返回值
`new`抛出 bac_alloc 异常,不返回 NULL
`malloc`返回 `NULL`

4. 指定内存大小不同
`new`不需要指定内存大小,编译器将自行计算
`malloc`需要显式指定大小
```cpp
class A{}
A *ptr = new A;
A *ptr = (A*)malloc(sizeof(A));
```
5. 是否调用构造函数和析构函数
`new`和`delete`的操作步骤
- 第一步:电泳 `operator new` 函数分配一块足够大的内存空间存储特定类型的对象
- 第二步:运行构造函数,传入初值
- 第三步:构造成功后,返回一个指向这个对象的指针.
- 第四步:调用析构函数
- 第五步:调用 `operator delete` 函数释放内存空间

6. 对数组的处理
`new[]`和`delete[]`专门用来处理数组类型
```cpp
A *ptr = new A[10];//分配十个 A 对象
delette []ptr;
```
他会调用构造函数初始化每一个数组元素,对每个对象进行析构
`malloc`只是给一块地址,和内存的地址,我们需要手动定义数组大小
```cpp
int *ptr = (int*) malloc(sizeof(int)*10)
```
7. 是否可以被重载
new 和 delete 可以被重载, malloc/free 不能

8. 能否直观重新分配内存
malloc 可以通过 realloc 函数来重新分配内存,new不行

|特征| new/delete|malloc/free|
|-|-|-|
|分配内存的位置|自由存储区|堆|
|分配成功的返回值|返回对象指针,类型安全|返回`void*`,需要强制转化
|分配失败的返回值|抛出异常|返回 NULL|
|分配内存的大小|自动根据对象大小分配|需要显式手动分配|
|处理数组|有专门的函数处理|需要计算大小后手动分配|
|已分配内存的扩充|没有|有`realloc`函数
|相互调用|可以调用 `malloc` 和 `free` 实现|不能|
|如果内存不足|能制定函数或者重新制定分配器|无法处理|
|重载|多种方式重载|不能|
|析构函数和构造函数|调用|不调用|
>实际上 new/delete 可以看成是 malloc/free加上构造,析构函数